---
output: github_document
---

# mcstatsim

## Monte Carlo Simulation Tools Using a Functional Approach

The `mcstatsim` package is a lightweight, dependency-free tool designed to facilitate statistical simulations through functional programming. It centralizes the simulation process into a single higher-order function, enhancing manageability and usability without adding overhead from external dependencies. The package includes ready-to-use functions for common simulation targets and processes simulation parameters via lists or expanded grids, all while utilizing parallel processing to improve efficiency on macOS and Linux-based distributions.


## Installation

You can install the latest development version of `mcstatsim` from GitHub:

```{r, eval=FALSE}
# install.packages("devtools")
devtools::install_github("ielbadisy/mcstatsim")
```


## Usage

Here is a basic example to get you started with `mcstatsim`:

```{r, eval=FALSE}
library(mcstatsim)

# Define a simple simulation function
sim_function <- function(a, b) {
  Sys.sleep(0.2)  # Simulate a time-consuming process
  return(data.frame(result = a + b))
}

# Generate a grid of parameters
params <- expand.grid(a = 1:3, b = 4:6)

# Run simulations
results <- runsim(n = 5, grid_params = params, sim_func = sim_function)
```

This example demonstrates how to define a simple simulation function, create a grid of parameters for the simulation, and run the simulations in parallel using `mcstatsim`.


## Working example

We'll create a naive scenario where we simulate simple regression data and fit a linear model to this data. This will demonstrate the creation of a simulation function, setting up parameters, and using mcstatsim to run these simulations in parallel.

### Step 1: Define the Simulation Function

This function will generate data based on a linear relationship with added random noise. We'll then fit a linear model to this data.
```{r}
simulate_and_analyze <- function(n, intercept, slope, noise_sd) {
  # Generate explanatory variable
  x <- runif(n, 0, 10)
  
  # Generate response variable with noise
  y <- intercept + slope * x + rnorm(n, mean = 0, sd = noise_sd)
  
  # Fit a linear model
  fit <- lm(y ~ x)
  
  # Extract coefficients
  coeffs <- coef(fit)
  
  # Return a dataframe containing the coefficients and their standard errors
  data.frame(
    intercept_est = coeffs["(Intercept)"],
    slope_est = coeffs["x"],
    intercept_se = summary(fit)$coefficients["(Intercept)", "Std. Error"],
    slope_se = summary(fit)$coefficients["x", "Std. Error"],
    n = n, 
    noise_sd = noise_sd
  )
 }
```

### Step 2: Set Up Simulation Parameters

We will create a grid of parameters to test different scenarios. For simplicity, we'll vary the number of observations and the standard deviation of the noise.
```{r}
params_grid <- expand.grid(
  n = c(100, 200),
  intercept = 2,
  slope = 3,
  noise_sd = c(1, 2)
  )
```

### Step 3: Run Simulations Using mcstatsim

Assuming mcstatsim is correctly set up for parallel processing, we use it to run simulations:
```{r}
library(mcstatsim)
# Ensure mcstatsim is installed and loaded
# install.packages("devtools")  # Uncomment if devtools is not installed
# devtools::install_github("your_github_username/mcstatsim")  # Adjust as necessary

results <- mcstatsim::runsim(n = 50, grid_params = params_grid, sim_func = simulate_and_analyze)
head(results)
```


### Step 4: Summerizing results
```{r}
library(dplyr)
library(ggplot2)

summary_results <- results %>%
  group_by(n, ID, noise_sd) %>%
  summarise(
    mean_intercept = mean(intercept_est),
    sd_intercept = sd(intercept_est),
    mean_slope = mean(slope_est),
    sd_slope = sd(slope_est),
    .groups = 'drop'  # This option removes the grouping structure after summarisation
  )

# Plotting Intercept Estimates
library(ggplot2)
ggplot(summary_results, aes(x = factor(n), y = mean_intercept, fill = factor(noise_sd))) +
  geom_bar(stat = "identity", position = position_dodge()) +
  geom_errorbar(aes(ymin = mean_intercept - sd_intercept, ymax = mean_intercept + sd_intercept),
                width = .2, position = position_dodge(.9)) +
  labs(title = "Intercept Estimates Across Different Conditions",
       x = "Sample Size",
       y = "Mean Intercept",
       fill = "Noise SD") +
  theme_minimal()

# Plotting Slope  Estimates
ggplot(summary_results, aes(x = factor(n), y = mean_slope, fill = factor(noise_sd))) +
  geom_bar(stat = "identity", position = position_dodge()) +
  geom_errorbar(aes(ymin = mean_slope - sd_slope, ymax = mean_slope + sd_slope),
                width = .2, position = position_dodge(.9)) +
  labs(title = "Slope Estimates Across Different Conditions",
       x = "Sample Size",
       y = "Mean Slope",
       fill = "Noise SD") +
  theme_minimal()
```

## Features

- **No Dependencies**: `mcstatsim` is designed to be lightweight and standalone, requiring no additional packages for its core functionalities, simplifying installation and usage.
- **Functional programming approach**: Streamlines the process of setting up and running simulations.
- **Parallel execution**: Leverages multiple cores to speed up the execution of simulations.
- **Structured output**: Returns simulation results in a dataframe, facilitating analysis and visualization.

## Limitations

- **Parallel processing mode**: `mcstatsim` utilizes parallel processing in multicore mode, which is only available on macOS and Linux-based distributions. Users on Windows may experience reduced performance or need to adjust for single-threaded execution.

## Contributing

Contributions to `mcstatsim` are welcome! Please refer to the [CONTRIBUTING.md](CONTRIBUTING.md) file for guidelines on how to make contributions.

## License

`mcstatsim` is licensed under the AGPL-3. Please see the [LICENSE](LICENSE.md) file for more details.

## Contact

For questions or feedback, please contact the package maintainer at `elbadisyimad@gmail.com`.
